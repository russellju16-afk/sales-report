/**
 * evidence_tables.js
 * Generates hidden HTML tables required by the Evidence Drawer.
 * These tables (e.g., total_customer_table) were previously generated by report.js.
 */
(function () {
    'use strict';

    const ROW_IDX = {
        date: 0,
        order: 1,
        cust: 2,
        cls: 3,
        name: 4,
        spec: 5,
        prod: 6,
        cat: 7,
        qty: 8,
        sales: 9,
        cost: 10,
        fee: 11,
        gp: 12,
        gpAdj: 13,
        unitPrice: 14
    };

    function fmtText(v) { return v || '-'; }
    function fmtWan(v) {
        if (typeof v !== 'number') return '-';
        return (v / 10000).toFixed(2);
    }
    function fmtPct(v) {
        if (typeof v !== 'number') return '-';
        return v.toFixed(1) + '%';
    }

    function sumRows(rows, keyIdx) {
        if (!rows) return 0;
        return rows.reduce((sum, r) => sum + (Number(r[keyIdx]) || 0), 0);
    }

    function groupBy(rows, keyIdx) {
        const map = {};
        rows.forEach(r => {
            const k = r[keyIdx] || 'Unknown';
            if (!map[k]) {
                map[k] = { key: k, sales: 0, gp: 0, gpAdj: 0, rows: [] };
            }
            map[k].sales += (Number(r[ROW_IDX.sales]) || 0);
            map[k].gp += (Number(r[ROW_IDX.gp]) || 0);
            map[k].gpAdj += (Number(r[ROW_IDX.gpAdj]) || 0);
            map[k].rows.push(r);
        });
        return Object.values(map).sort((a, b) => b.sales - a.sales);
    }

    function renderTable(id, data, cols, formatters) {
        let table = document.getElementById(id);
        if (!table) {
            // Create if not exists (should be in a hidden container)
            const container = document.getElementById('evidence_tables_container');
            if (!container) return; // Should allow container to be created if missing?

            table = document.createElement('table');
            table.id = id;
            table.className = 'report-table'; // reuse styles if needed, though hidden
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            cols.forEach(c => {
                const th = document.createElement('th');
                th.textContent = c.key; // simple header
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            table.appendChild(thead);
            table.appendChild(document.createElement('tbody'));
            container.appendChild(table);
        }

        const tbody = table.tBodies[0];
        tbody.innerHTML = '';

        data.forEach(item => {
            const tr = document.createElement('tr');
            cols.forEach((c, i) => {
                const td = document.createElement('td');
                const fn = formatters[i];
                let val;
                // Special handlings based on column key or index? 
                // We match the formatters passed in.
                // The item is the aggregated object { key, sales, gp... }
                if (c.key === 'key') val = item.key;
                else if (c.key === 'sales') val = item.sales;
                else if (c.key === 'share') val = item.sales; // calculation happens in formatter
                else if (c.key === 'gm') val = item.sales ? (item.gp / item.sales * 100) : 0;
                else if (c.key === 'gmAdj') val = item.sales ? (item.gpAdj / item.sales * 100) : 0;

                td.textContent = fn ? fn(val, item) : val;
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });
    }

    function initEvidenceTables(normalizedData) {
        // Ensure container exists
        let container = document.getElementById('evidence_tables_container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'evidence_tables_container';
            container.style.display = 'none'; // Hidden
            document.body.appendChild(container);
        }

        const seg = normalizedData.segments.total || {};
        const rows = seg.rows || [];
        const totalSales = sumRows(rows, ROW_IDX.sales);

        // 1. Top Customers
        const topCusts = groupBy(rows, ROW_IDX.cust).slice(0, 50); // Keep top 50 needed for evidence
        renderTable('total_customer_table', topCusts, [
            { key: 'key' },
            { key: 'sales' },
            { key: 'share' },
            { key: 'gm' },
            { key: 'gmAdj' }
        ], [
            (v) => fmtText(v),
            (v) => fmtWan(v),
            (v, item) => {
                const ratio = totalSales ? (item.sales / totalSales * 100) : 0;
                return fmtPct(ratio);
            },
            (v) => fmtPct(v),
            (v) => fmtPct(v)
        ]);

        // 2. Top Products
        const topProds = groupBy(rows, ROW_IDX.prod).slice(0, 50);
        renderTable('total_product_table', topProds, [
            { key: 'key' },
            { key: 'sales' },
            { key: 'share' },
            { key: 'gm' },
            { key: 'gmAdj' }
        ], [
            (v) => fmtText(v),
            (v) => fmtWan(v),
            (v, item) => {
                const ratio = totalSales ? (item.sales / totalSales * 100) : 0;
                return fmtPct(ratio);
            },
            (v) => fmtPct(v),
            (v) => fmtPct(v)
        ]);
    }

    // Expose
    window.EvidenceTables = {
        init: initEvidenceTables
    };

})();
